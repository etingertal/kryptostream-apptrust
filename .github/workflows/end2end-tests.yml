name: End 2 End Tests

on:
  workflow_dispatch:
    # inputs:
    #   promote_to_qa:
    #     description: 'Promote to QA environment'
    #     required: false
    #     default: true
    #     type: boolean

jobs:
  end2end-tests:
    name: Promote to QA and run E2E tests
    runs-on: ubuntu-latest
    env:
      JFROG_CLI_KEY_ALIAS: ${{ vars.JFROG_CLI_KEY_ALIAS }}
      JFROG_CLI_SIGNING_KEY: ${{ secrets.JFROG_CLI_SIGNING_KEY }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup JFrog CLI
      uses: jfrog/setup-jfrog-cli@v4
      with:
        version: latest
      env:
        JF_URL: ${{ vars.JF_URL }}
        JF_USER: ${{ vars.JF_USER }}
        JF_ACCESS_TOKEN: ${{ secrets.JF_ACCESS_TOKEN }}
    
    - name: Get latest DEV release bundle version
      id: get-latest-dev-version
      run: |
        # Fetch promotion records from Artifactory API
        PROMOTION_RESPONSE=$(curl -s -X GET \
          -H "Authorization: Bearer ${{ secrets.JF_ACCESS_TOKEN }}" \
          "${{ vars.JF_URL }}/lifecycle/api/v2/promotion/records/quotopia")

        # Filter for environment "DEV", sort by "created" field in descending order, and get the first one
        LATEST_DEV_VERSION=$(echo "$PROMOTION_RESPONSE" | \
          jq -r '.promotions | map(select(.environment == "DEV")) | sort_by(.created) | reverse | .[0].release_bundle_version')
        
        echo "latest_dev_version=$LATEST_DEV_VERSION" >> $GITHUB_OUTPUT
        echo "Found latest DEV release bundle version: $LATEST_DEV_VERSION"
    
    - name: Set QA version (when promotion is skipped)
      if: ${{ inputs.promote_to_qa != 'true' }}
      run: |
        LATEST_DEV_VERSION="${{ steps.get-latest-dev-version.outputs.latest_dev_version }}"
        echo "üìã Using DEV version $LATEST_DEV_VERSION for QA testing (no promotion)"
        echo "LATEST_QA_VERSION=$LATEST_DEV_VERSION" >> $GITHUB_ENV
      
    - name: Cache npm dependencies
      uses: actions/cache@v4
      with:
        path: |
          e2e-tests/node_modules
          ~/.npm
        key: ${{ runner.os }}-npm-${{ hashFiles('e2e-tests/package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-npm-

    - name: Login to Docker Registry
      run: |
        echo "üîê Logging into JFrog Artifactory Docker registry..."
        echo "Registry: ${{ vars.JF_URL }}"
        echo ${{ secrets.JF_ACCESS_TOKEN }} | docker login -u ${{ vars.JF_USER }} --password-stdin ${{ vars.JF_URL }}
        echo "‚úÖ Successfully logged into Docker registry"
        
    - name: Get Docker images from QA repository
      id: get-images
      run: |
        # Get the latest QA version
        LATEST_QA_VERSION="${{ env.LATEST_QA_VERSION }}"
        echo "Testing with QA version: $LATEST_QA_VERSION"
        
        # Get Docker image tags from QA repository using AQL with better error handling
        echo "üîç Searching for quote service images..."
        QUOTE_RESPONSE=$(curl -s -X POST \
          -H "Authorization: Bearer ${{ secrets.JF_ACCESS_TOKEN }}" \
          -H "Content-Type: text/plain" \
          -d 'items.find({"repo": "commons-qa-docker-local", "name": "list.manifest.json", "path": {"$match": "quoteofday/*"}}).sort({"$desc": ["created"]}).limit(1)' \
            "${{ vars.JF_URL }}/artifactory/api/search/aql")
        
        echo "Quote API Response: $QUOTE_RESPONSE"
        
        if [ -z "$QUOTE_RESPONSE" ] || [ "$QUOTE_RESPONSE" = "null" ]; then
          echo "‚ùå No quote service images found in QA repository"
          exit 1
        fi
        
        QUOTE_IMAGE_TAG=$(echo "$QUOTE_RESPONSE" | jq -r '.results[0].path | split("/") | .[1] // empty')
        
        if [ -z "$QUOTE_IMAGE_TAG" ]; then
          echo "‚ùå Failed to extract quote image tag from response"
          echo "Response: $QUOTE_RESPONSE"
          exit 1
        fi
        
        echo "‚úÖ Found quote service image tag: $QUOTE_IMAGE_TAG"
        
        echo "üîç Searching for translation service images..."
        TRANSLATION_RESPONSE=$(curl -s -X POST \
          -H "Authorization: Bearer ${{ secrets.JF_ACCESS_TOKEN }}" \
          -H "Content-Type: text/plain" \
          -d 'items.find({"repo": "commons-qa-docker-local", "name": "list.manifest.json", "path": {"$match": "ai-translate/*"}}).sort({"$desc": ["created"]}).limit(1)' \
            "${{ vars.JF_URL }}/artifactory/api/search/aql")
        
        echo "Translation API Response: $TRANSLATION_RESPONSE"
        
        if [ -z "$TRANSLATION_RESPONSE" ] || [ "$TRANSLATION_RESPONSE" = "null" ]; then
          echo "‚ùå No translation service images found in QA repository"
          exit 1
        fi
        
        TRANSLATION_IMAGE_TAG=$(echo "$TRANSLATION_RESPONSE" | jq -r '.results[0].path | split("/") | .[1] // empty')
        
        if [ -z "$TRANSLATION_IMAGE_TAG" ]; then
          echo "‚ùå Failed to extract translation image tag from response"
          echo "Response: $TRANSLATION_RESPONSE"
          exit 1
        fi
        
        echo "‚úÖ Found translation service image tag: $TRANSLATION_IMAGE_TAG"

        echo "quote_image_tag=$QUOTE_IMAGE_TAG" >> $GITHUB_OUTPUT
        echo "translation_image_tag=$TRANSLATION_IMAGE_TAG" >> $GITHUB_OUTPUT
        
        echo "Quote service image: evidencetrial.jfrog.io/commons-qa-docker-local/quoteofday:$QUOTE_IMAGE_TAG" >> $GITHUB_STEP_SUMMARY
        echo "Translation service image: evidencetrial.jfrog.io/commons-qa-docker-local/ai-translate:$TRANSLATION_IMAGE_TAG" >> $GITHUB_STEP_SUMMARY
        
    - name: Generate E2E test Docker Compose file
      run: |
        # Set environment variables for template substitution
        export QUOTE_IMAGE_TAG="${{ steps.get-images.outputs.quote_image_tag }}"
        export TRANSLATION_IMAGE_TAG="${{ steps.get-images.outputs.translation_image_tag }}"
        
        # Substitute variables in the template
        envsubst < e2e-tests/docker-compose.yml.template > e2e-test-compose.yml
        
        # Display the generated file for debugging
        echo "Generated Docker Compose file:"
        cat e2e-test-compose.yml
        
    - name: Run E2E tests 
      run: |
        # Start services and run tests
        echo "üöÄ Starting E2E tests..."
        
        # Pull images in parallel for faster startup
        docker pull evidencetrial.jfrog.io/commons-qa-docker-local/quoteofday:${{ steps.get-images.outputs.quote_image_tag }} &
        docker pull evidencetrial.jfrog.io/commons-qa-docker-local/ai-translate:${{ steps.get-images.outputs.translation_image_tag }} &
        wait
        
        # Start services and run tests
        docker compose -f e2e-test-compose.yml up --abort-on-container-exit
        
        # Check if tests passed
        if [ $? -eq 0 ]; then
          echo "‚úÖ E2E tests completed successfully"
        else
          echo "‚ùå E2E tests failed"
          exit 1
        fi
        
    - name: Generate test reports
      run: |
        echo "üìÑ Generating test reports..."
        
        # Navigate to e2e-tests directory
        cd e2e-tests
        
        # Check if mochawesome results exist
        if [ ! -d "cypress/results/mochawesome" ] || [ -z "$(ls -A cypress/results/mochawesome/*.json 2>/dev/null)" ]; then
          echo "‚ùå No mochawesome results found"
          exit 1
        fi
        
        echo "‚úÖ Found mochawesome results"
        
        # Merge JSON reports (same as local flow)
        echo "üîÑ Merging JSON reports..."
        npx mochawesome-merge cypress/results/mochawesome/*.json > cypress/results/combined-report.json
        
        if [ ! -f "cypress/results/combined-report.json" ]; then
          echo "‚ùå Failed to create combined report"
          exit 1
        fi
        
        echo "‚úÖ Combined report created: $(wc -c < cypress/results/combined-report.json) bytes"
        
        # Convert to markdown (same as local flow)
        echo "üîÑ Converting to markdown..."
        ./convert-cypress-report.sh cypress/results/combined-report.json cypress-report.md
        
        if [ ! -f "cypress-report.md" ]; then
          echo "‚ùå Failed to create markdown report"
          exit 1
        fi
        
        echo "‚úÖ Markdown report created: $(wc -c < cypress-report.md) bytes"
        
        # Copy reports to workspace root for easy access
        cp cypress/results/combined-report.json ../cypress-results.json
        cp cypress-report.md ../cypress-e2e-report.md
        
        echo "üìä Report Summary:"
        head -20 cypress-report.md

    - name: Create evidence from the e2e test results
      run: |
        echo "üìã Creating evidence from test results..."
        
        # Validate JSON before creating evidence
        if ! jq empty cypress-results.json 2>/dev/null; then
          echo "‚ùå Invalid JSON in cypress-results.json"
          exit 1
        fi
        
        echo "‚úÖ Valid JSON confirmed"
        
        jf evd create --release-bundle quotopia --release-bundle-version ${{ steps.get-latest-dev-version.outputs.latest_dev_version }} \
          --predicate cypress-results.json --markdown cypress-e2e-report.md --provider-id cypress --predicate-type https://cypress.io/evidence/e2e/v1

    - name: Upload Cypress Markdown Report
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: cypress-e2e-report
        path: cypress-e2e-report.md
        retention-days: 30
        if-no-files-found: error

    - name: Cleanup
      if: always()
      run: |
        # Clean up generated files and containers
        rm -f e2e-test-compose.yml cypress-results.json cypress-e2e-report.md
        docker compose -f e2e-test-compose.yml down -v 2>/dev/null || true
        docker system prune -f
        
